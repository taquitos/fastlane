require 'fileutils'

skip_docs

desc "Runs the unit tests and other verifications for the fastlane repo"
lane :test do |options|
  validate_repo
end

desc "Generate the Swift api and test it"
lane :generate_swift_api do |options|
  require "../fastlane/lib/fastlane/swift_fastlane_api_generator.rb"
  swift_generator = Fastlane::SwiftFastlaneAPIGenerator.new
  swift_generator.generate_swift
  UI.success("Done generating fastlane.swift API, ensuring it builds")
  gym(
    project: File.expand_path("swift/FastlaneSwiftRunner/FastlaneSwiftRunner.xcodeproj"),
    skip_package_ipa: true
  )
  sh("rm ../FastlaneRunner")
end

desc "Increment the version number of this gem and autogenerate Swift API"
lane :swift_gen_and_bump do |options|
  ensure_git_branch(branch: "master")
  ensure_git_status_clean

  github_api_token = ENV["FL_GITHUB_RELEASE_API_TOKEN"]
  UI.user_error!("Please provide a GitHub API token using `FL_GITHUB_RELEASE_API_TOKEN`") if github_api_token.to_s.length == 0

  # Generate swift api and make sure it builds, so we don't fail later after asking for user input
  generate_swift_api

  version_path = "./fastlane/lib/fastlane/version.rb"
  swift_api_path = "./fastlane/swift"

  # Verify everything is in a consistent state
  latest_version = current_version
  local_version = version_get_podspec(path: version_path)
  UI.user_error!("Version on RubyGems doesn't match local repo: #{latest_version} != #{local_version}") if latest_version != local_version

  changelog_text = show_changelog

  bump_type ||= 'minor' if prompt(text: "New feature, method or API?", boolean: true)
  bump_type ||= 'patch'

  slug = "fastlane/fastlane"
  new_version = version_bump_podspec(path: version_path, bump_type: bump_type)
  sh "git checkout -b 'version-bump-#{new_version}'"
  commit_message = "Version bump to #{new_version}"
  git_commit(path: version_path,
             message: commit_message)

  git_commit(path: swift_api_path,
             message: "Autogenerated Swift API updates")
  push_to_git_remote

  pr_body = ["Auto-generated by fastlane ðŸ¤–"]
  pr_body << "**Changes since release '#{latest_version}':**"
  pr_body << changelog_text
  pr_url = create_pull_request(
    api_token: github_api_token,
    repo: slug,
    title: commit_message,
    body: pr_body.join("\n\n")
  )

  if ENV['SLACK_URL']
    slack(
      channel: "action",
      default_payloads: [],
      message: "Version bump: #{pr_url} âœ¨",
      payload: {}
    )
  end

  # Revert to master branch
  sh "git checkout master"
end

desc "Does everything that's needed for a release"
desc "This includes running tests and verifying the GitHub release"
lane :release do
  slack_train_start(distance: 2,
                       train: "ðŸš€",
           reverse_direction: true,
                        rail: "âœ¨")

  update_fastlane
  slack_train

  # Git verification
  #
  ensure_git_status_clean
  ensure_git_branch(branch: 'master')
  git_pull

  validate_repo

  # Verifying RubyGems version
  #
  require "../fastlane/lib/fastlane/version.rb"
  version = Fastlane::VERSION
  old_version = current_version
  puts "Deploying #{version}"
  if Gem::Version.new(version) <= Gem::Version.new(old_version)
    UI.user_error!("Version number #{version} was already deployed")
  end

  # Then push to git remote
  #
  push_to_git_remote

  # Preparing GitHub Release
  #
  github_release = get_github_release(url: "fastlane/fastlane", version: version)
  if (github_release || {}).fetch('body', '').length == 0
    show_changelog(old_version: old_version)

    title = prompt(text: 'Title: ')
    description = prompt(text: "Please enter a changelog (make sure to rephrase changes to make it easy to understand, and remove non-important changes that don't affect the end-user): ",
                         multi_line_end_keyword: "END")

    github_release = set_github_release(
      repository_name: "fastlane/fastlane",
      name: [version, title].join(" "),
      tag_name: version,
      description: description,
      is_draft: false
    )

    # Actual release of the gem
    #
    sh "gem push ../pkg/fastlane-#{version}.gem"

    release_url = github_release['html_url']

    message = [title, description, release_url].join("\n\n")
    add_fastlane_git_tag(tag: "fastlane/#{version}", message: message)
  end

  # After publishing
  #
  if ENV['SLACK_URL']
    release_notes = github_release['body']
    # markup - turn github references into links
    release_notes.gsub!(/\(#([0-9]+)\)/, '(<https://github.com/fastlane/fastlane/issues/\1|#\1>)')
    slack_message = "Successfully released [fastlane #{version}](#{release_url}) :rocket:"
    slack(
      channel: "releases",
      default_payloads: [],
      message: slack_message,
      payload: {
        "New" => release_notes
      }
    )
    slack(channel: "action", default_payloads: [], message: slack_message)
  end

  clubmate

  puts "You can now tweet:".green
  releases_url = "https://github.com/fastlane/fastlane/releases/tag/#{version}"
  puts "[fastlane] #{github_release['name']} #{releases_url}"

  send_mac_app_ci_reminder

  update_docs
  slack_train
end

desc "Makes sure the tests on https://docs.fastlane.tools still work with the latest version"
lane :verify_docs do
  clone_docs do
    Bundler.with_clean_env do
      puts `sed -i -e "s/activate_bin_path/bin_path/g" $(which bundle)` # workaround for bundler https://github.com/bundler/bundler/issues/4602#issuecomment-233619696
      sh "bundle install"
      sh "bundle exec fastlane test skip_building:true" # skip_building since we don't have a proper python environment set up
    end
  end
end

desc "Update the actions.md on https://docs.fastlane.tools"
desc "This will also automatically submit a pull request to fastlane/docs"
lane :update_docs do
  verify_env_variables

  template_path = File.expand_path("./assets/render_plugin.md.erb")
  clone_docs do
    docs_path = generate_markdown_docs(target_path: ".")
    actions_md_path = File.expand_path(File.join(docs_path, "docs/actions.md"))
    action_docs = Dir[File.join(docs_path, "docs", "actions", "*")].collect do |current|
      File.expand_path(current) # to make sure we commit the change
    end

    # Copy over the custom assets
    custom_action_docs = "lib/fastlane/actions/docs/"
    custom_assets = Dir[File.join(Fastlane::ROOT, custom_action_docs, "assets", "*")].collect do |current_asset_path|
      current_output_path = File.join("docs/img/actions", File.basename(current_asset_path))
      FileUtils.cp(current_asset_path, current_output_path)

      File.expand_path(current_output_path) # to make sure we commit the change
    end

    Bundler.with_clean_env do
      sh "bundle update"
    end

    if `git status --porcelain`.length == 0
      UI.success("No changes in the actions.md âœ…")
    else
      # Create a new branch
      sh "git checkout -b 'update-actions-md-#{Time.now.to_i}'"
      plugins_path = "docs/plugins/available-plugins.md"
      plugin_scores(template_path: template_path,
                      output_path: plugins_path)

      Dir.chdir("fastlane") do # this is an assumption of fastlane, that we have to .. when shelling out
        # Commit the changes
        changes_to_commit = [actions_md_path, "Gemfile.lock", plugins_path] + action_docs + custom_assets
        git_add(path: changes_to_commit)
        git_commit(path: changes_to_commit,
                message: "Update docs for latest fastlane release (actions.md, available-plugins.md) ðŸš€")
        # Push them to the git remote
        push_to_git_remote

        # Submit the pull request
        pr_url = create_pull_request(
          api_token: ENV["FL_GITHUB_RELEASE_API_TOKEN"],
          repo: "fastlane/docs",
          title: "[Bot] Update docs for latest fastlane release (actions.md, available-plugins.md) ðŸš€",
          body: "Auto-generated by _fastlane_ bot ðŸ¤–"
        )
        UI.success("Successfully submitted a pull request to fastlane/docs: #{pr_url} ðŸš€")
      end
    end
  end
end

def generate_markdown_docs(target_path: nil)
  require 'fastlane/documentation/markdown_docs_generator'
  Fastlane::MarkdownDocsGenerator.new.generate!(target_path: File.expand_path(target_path))
  return target_path
end

def clone_docs
  require 'tmpdir'
  git_url = ENV['FASTLANE_DOCS_GIT_URL'] || "https://github.com/fastlane/docs"

  Dir.mktmpdir("fl_clone") do |tmp_dir|
    Dir.chdir(tmp_dir) do
      sh "git clone #{git_url} --depth=1"
      Dir.chdir("docs") do
        yield
      end
    end
  end
end

error do |lane, exception|
  if ENV['SLACK_URL']
    slack(channel: "testing", message: exception.to_s, success: false)
  end
  slack_train_crash
end

private_lane :send_mac_app_ci_reminder do
  if ENV['FABRIC_SLACK_URL']
    slack(
      slack_url: ENV['FABRIC_SLACK_URL'],
      channel: 'deployment-tools',
      default_payloads: [],
      message: "Please run the Fastlane Mac App Package CI job in TeamCity\n#{ENV['FABRIC_MAC_APP_CI_JOB_URL']}"
    )
  end
end

desc "Verifies all tests pass and the current state of the repo is valid"
private_lane :validate_repo do
  # Verifying that no debug code is in the code base
  #
  ensure_no_debug_code(text: "binding.pry", extension: ".rb", exclude: "playground.rb", exclude_dirs: ["\.bundle"]) # debugging code
  ensure_no_debug_code(text: "# TODO", extension: ".rb", exclude_dirs: ["\.bundle"]) # TODOs
  ensure_no_debug_code(text: "now: ", extension: ".rb", exclude_dirs: ["\.bundle"]) # rspec focus
  ensure_no_debug_code(text: "<<<<<<<", extension: ".rb", exclude_dirs: ["\.bundle"]) # Merge conflict

  # spaceship and credentials_manager don't have access to fastlane_core
  ensure_no_debug_code(text: " UI\\.", path: "spaceship/lib", extension: ".rb", exclude_dirs: ["\.bundle"])
  ensure_no_debug_code(text: " UI\\.", path: "credentials_manager/lib", extension: ".rb", exclude_dirs: ["\.bundle"])

  rubocop

  # Verifying the --help command
  #
  Dir.chdir("..") do
    content = sh("PAGER=cat bin/fastlane --help")
    ["--version", "https://fastlane.tools", "fastlane"].each do |current|
      UI.user_error!("--help missing information: '#{current}'") unless content.include?(current)
    end
  end

  Dir.chdir("..") do
    # Install the bundle and the actual gem
    sh "bundle check || bundle install"
    sh "rake install"

    # Run the tests
    #
    sh "bundle exec rake test_all"

    # Verify shell code style
    sh 'find -E . -regex ".*\.(sh|bash)" -not -name "Pods-*" -name ".bundle" -exec shellcheck {} +'
  end

  # Test if generating the docs is successful
  clone_docs do
    generate_markdown_docs(target_path: ".")
  end

  # Verify docs are still working
  verify_docs
end

desc "Get the version number of the last release"
private_lane :current_version do
  puts "Checking the latest version on RubyGems"
  download(url: "https://rubygems.org/api/v1/gems/fastlane.json")["version"]
end

desc "Print out the changelog since the last tagged release and open the GitHub page with the changes"
lane :show_changelog do |options|
  old_version = options[:old_version] || current_version

  changes = sh("git log --pretty='* %s via %aN' #{old_version}...HEAD --no-merges ..", log: $verbose).gsub("\n\n", "\n")
  changes.gsub!("[WIP]", "") # sometimes a [WIP] is merged

  github_diff_url = "https://github.com/fastlane/fastlane/compare/#{old_version}...master"
  sh "open #{github_diff_url}"

  puts "Changes since release #{old_version}:\n\n#{changes.cyan}"
  changes # return the text without the modified colors
end

desc "Add a git tag in the fastlane repo for this release"
private_lane :add_fastlane_git_tag do |options|
  `git tag -am #{options[:message].shellescape} #{options[:tag].shellescape}`
  push_git_tags
end

desc "Ensure all the requirement environment variables are provided"
desc "this way the deployment script will fail early (and often)"
private_lane :verify_env_variables do
  ["GITHUB_USER_NAME", "GITHUB_API_TOKEN"].each do |variable|
    next if ENV[variable].to_s.length > 0
    UI.user_error!("Missing ENV variables #{variable}, make sure to provide one for fastlane to be successful")
  end
end
